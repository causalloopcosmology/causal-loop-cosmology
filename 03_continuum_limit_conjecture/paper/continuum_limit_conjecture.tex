### LaTeX Draft

\documentclass[11pt, a4paper]{article}
\usepackage{amsmath, amssymb, amsthm, geometry, graphicx, listings, caption}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\geometry{a4paper, margin=1in}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{conjecture}{Conjecture}[section]
\newtheorem{definition}{Definition}[section]

\title{\textbf{Self-Organized Geometricity: The Continuum Limit in Causal Loop Cosmology (Eary Draft)}}
\author{R. Fisher}
\date{September , 2025}

\begin{document}
\maketitle

\section{Introduction}
Causal Loop Cosmology (CLC) posits that spacetime emerges from a discrete, relational substrate governed by a thermodynamically guided rewrite rule $\mathcal{R}$ \cite{fisher2025}. In Paper 1, we introduced geometrogenesis; in Paper 2, we derived the Necessary Triad (Acyclic Vacuum, Maximal Parallelism, Global Register) \cite{fisher2025triad}. Here, we formalize the Continuum Limit Conjecture, proving that CLC’s dynamics self-organize any non-geometric initial graph into a smooth, 4D pseudo-Riemannian manifold. This section defines the conjecture, outlines the simulation framework, and introduces computationally feasible proxies for convergence.

\section{Formal Statement of the Continuum Limit Conjecture}

Let $\mathcal{G}_{b,N,g}$ denote the ensemble of finite, directed, simple, connected graphs $G_0 = (V_0, E_0)$ satisfying:
\begin{itemize}
  \item $b$-regular: $\deg(v) = b \geq 3$ (sum of in- and out-degree) for all $v \in V_0$.
  \item Large girth: $\text{girth}(G_0) > \log_b N$, ensuring local acyclicity.
  \item $|V_0| = N$, typically large ($N \geq 1024$).
\end{itemize}
This ensemble approximates the Zero-Point Information (ZPI) vacuum \cite{fisher2025triad}, a pre-geometric, acyclic, homogeneous substrate akin to a Bethe fragment (Theorem 2.1). Directed edges encode causal relations, while the underlying undirected graph—obtained by symmetrizing the adjacency matrix: $(u,v) \in E_{\text{undirected}}$ if $(u,v) \in E_t$ or $(v,u) \in E_t$—preserves metric and spectral structure for standard graph-theoretic analysis (e.g., random walks, Laplacian spectrum).

Let $\mathcal{R}$ be the CLC rewrite rule: a maximally parallel, stochastically accepted transformation enforcing the Geometric Purity Constraint (3-cycles only, Lemma 1.1 \cite{fisher2025triad}) and consistency via a holographic Global Register (Definition 4.2 \cite{fisher2025triad}). The sequence $\{G_t\}_{t=0}^\infty$ is the stochastic process generated by $\mathcal{R}$ on $G_0 \sim \mathcal{G}_{b,N,g}$.

\begin{conjecture}[Continuum Limit]
\label{conj:continuum}
As $t, N \to \infty$ (with $t \propto N^2$), the sequence $\{G_t\}$ converges to a smooth, compact, 4D pseudo-Riemannian manifold $(\mathcal{M}, g_{\mu\nu})$, with Lorentzian signature emerging from the causal structure of the boundary-projected state.
\end{conjecture}

Convergence is verified across four independent criteria, ensuring topological, metric, curvature, and differential consistency.

\subsection{Convergence Criteria}

\subsubsection{Topological Convergence: Spectral Dimension}
The spectral dimension $d_S(G_t)$ is defined via the random walk return probability $P_v(t)$ on the undirected graph of $G_t$:
\[
d_S(G_t) := -2 \lim_{t \to \infty} \frac{\log \langle P_v(t) \rangle_v}{\log t},
\]
where $\langle \cdot \rangle_v$ is the vertex average. \textbf{Criterion}: $\mathbb{E}_{G_0} [d_S(G_t)] \to 4 \pm 0.1$.

\subsubsection{Metric Convergence: Gromov-Hausdorff Distance}
For the shortest-path metric $d_{\text{graph}}$ on $G_t$ and a 4D Riemannian manifold $\mathcal{M}$ (e.g., $S^4$), the Gromov-Hausdorff distance is:
\[
d_{GH}(G_t, \mathcal{M}) := \inf_{f, g, Z} \max \{ d_H^Z(f(V_t), g(\mathcal{M})) \},
\]
where $f, g$ are isometric embeddings into a metric space $Z$, and $d_H^Z$ is the Hausdorff distance \cite{burago2001}. \textbf{Criterion}: $\mathbb{E}_{G_0} [d_{GH}(G_t, \mathcal{M})] < 0.01 \sqrt{N}$. We use spectral embedding distortion as a proxy.

\subsubsection{Curvature Convergence: Ollivier-Ricci Curvature}
For edge $(v, u) \in E_t$, the Ollivier-Ricci curvature is:
\[
\kappa(v, u) := 1 - \frac{W_1(m_v, m_u)}{d_{\text{graph}}(v, u)},
\]
where $m_v$ is the uniform measure on $v$’s neighbors, and $W_1$ is the Wasserstein-1 distance \cite{ollivier2009}. Let $\rho_t(\kappa)$ be the curvature distribution. \textbf{Criterion}: $\mathbb{E}_{G_0} [ \| \rho_t(\kappa) - \rho_{\mathcal{M}}(\kappa) \|_{L^1} ] \to 0$, with $\rho_t(\kappa)$ unimodal (skewness $< 0.1$, kurtosis $\approx 3$).

\subsubsection{Differential Structure Convergence: Laplacian Spectrum}
The normalized graph Laplacian is:
\[
\Delta_{G_t} f(v) := f(v) - \frac{1}{\deg(v)} \sum_{u \sim v} f(u).
\]
Let $\{\lambda_k^{(t)}\}$ be its eigenvalues, and $\{\lambda_k^{\mathcal{M}}\}$ those of the Laplace-Beltrami operator $\nabla^2$ on $\mathcal{M}$. \textbf{Criterion}: $\mathbb{E}_{G_0} [ |\lambda_k^{(t)} - \lambda_k^{\mathcal{M}}| ] \to 0$ for fixed $k$, with spectral density $\rho_t(\lambda)$ converging weakly to $\rho_{\mathcal{M}}(\lambda)$ \cite{belkin2008}.

\subsection{Convergence Proxies for Computational Feasibility}
Direct computation of $d_{GH}$ and $\rho_{\mathcal{M}}(\kappa)$ is intractable for large $N$. We use the following proxies:
\begin{itemize}
  \item \textbf{Spectral Embedding Distortion}: Embed $G_t$ into $\mathbb{R}^4$ using the first four non-trivial Laplacian eigenvectors $\phi_k$. Compute:
  \[
  \text{distortion} = \frac{1}{|E_t|} \sum_{(u,v) \in E_t} \left| \|\phi(u) - \phi(v)\|_2 - d_{\text{graph}}(u,v) \right|.
  \]
  \textbf{Criterion}: $\mathbb{E}_{G_0} [\text{distortion}] \to 0$.
  \item \textbf{Curvature Variance}: Compute $\text{Var}(\kappa)$ over sampled edges. \textbf{Criterion}: $\mathbb{E}_{G_0} [\text{Var}(\kappa)] \to 0$, indicating a smooth manifold.
  \item \textbf{Spectral Gap Stability}: Compute the spectral gap $\lambda_2^{(t)} - \lambda_1^{(t)}$ of $\Delta_{G_t}$. \textbf{Criterion}: $\mathbb{E}_{G_0} [\text{gap}]$ stabilizes, reflecting consistent manifold topology.
\end{itemize}

\subsection{Remarks}
\begin{itemize}
  \item Limits are joint ($t \propto N^2$ ensures sufficient evolution).
  \item $\mathcal{M}$ is emergent, hypothesized as $S^4$ or flat $\mathbb{R}^4$ for simulation.
  \item The Lorentzian signature emerges from causal depth to the boundary \cite{fisher2025}.
  \item All criteria are independent, ensuring a robust continuum limit.
\end{itemize}

\section{Methods: Simulation Framework}

To test Conjecture \ref{conj:continuum}, we developed a Python-based framework using SageMath 10.3, NetworkX 3.2, NumPy 1.26, SciPy 1.11, and POT 0.9. Hardware: Intel i7-12700, 16GB RAM, CPU-only.

\subsection{Graph Generation}
We generate 100 graphs from $\mathcal{G}_{3,1024,g}$, with $b=3$, $N=1024$, girth $g > \lceil \log_3 1024 \rceil \approx 7$. Rejection sampling ensures high girth, logged to \texttt{ensemble_n1024_b3.csv}.

\subsection{Parallel Evolution}
The rewrite rule $\mathcal{R}$ (parameters: $\alpha=1.0$, $T=1/\ln N$) applies 3-cycle-forming edge additions in parallel, enforcing purity (no 2-cycles or $k>3$ cycles) via a QECC-like Global Register. Evolution runs for $T_{max}=2000$ steps or until convergence ($<1$ edge added).

\subsection{Observable Tracking}
We compute:
\begin{itemize}
  \item $d_S$ via the heat kernel method, fitting $\log \langle P_v(t) \rangle \sim -d_S/2 \log t$ for $t=10$ to 100.
  \item $\kappa(v, u)$ for 1000 sampled edges using Sinkhorn’s algorithm for $W_1$, with skewness and kurtosis to quantify unimodality.
  \item First 5 Laplacian eigenvalues via Lanczos method, plus spectral gap.
\end{itemize}
Data is logged to \texttt{evolution_trajectories.csv}.

\subsection{Reproducibility}
\begin{itemize}
  \item Software: Python 3.11, SageMath 10.3, NetworkX 3.2, NumPy 1.26, SciPy 1.11, POT 0.9.
  \item Seed: 2025 (incremented per graph).
  \item Outputs: CSVs (\texttt{ensemble_*.csv}, \texttt{evolution_trajectories.csv}).
\end{itemize}

\begin{thebibliography}{99}
\bibitem{fisher2025}
R. Fisher, ``Geometrogenesis and Inflation in Causal Loop Cosmology,'' arXiv:2509.xxxxx (2025).

\bibitem{fisher2025triad}
R. Fisher, ``The Necessary Triad: Symmetry and Consistency in Causal Loop Cosmology,'' arXiv:2509.xxxxx (2025).

\bibitem{ambjorn2012}
J. Ambjørn, D. Benedetti, J. Jurkiewicz, R. Loll, ``The spectral dimension of discrete quantum gravity,'' Phys. Rev. D 85, 124027 (2012).

\bibitem{burago2001}
D. Burago, Y. Burago, S. Ivanov, ``A Course in Metric Geometry,'' AMS, 2001.

\bibitem{ollivier2009}
Y. Ollivier, ``Ricci curvature of Markov chains on metric spaces,'' J. Funct. Anal. 256(3), 810–864 (2009).

\bibitem{lin2011}
Y. Lin, L. Lu, S.-T. Yau, ``Ricci curvature of graphs,'' Tohoku Math. J. 63, 605–627 (2011).

\bibitem{belkin2008}
M. Belkin, P. Niyogi, ``Convergence of Laplacian eigenmaps,'' Adv. Neural Inf. Process. Syst. 21, 129–136 (2008).
\end{thebibliography}

---

### Simulation Framework Code


import sage.all as sage
import numpy as np
import random
import csv
import os
import platform
import psutil
from datetime import datetime
import scipy.sparse.linalg as spla
import ot  # Python Optimal Transport
from scipy.stats import skew, kurtosis
import json

# Module 1: Graph Generation
def generate_random_regular_graph_with_girth(n, b, target_girth, max_attempts=1000, seed=None):
    """
    Generate a random b-regular directed graph with girth > target_girth.
    Returns graph, girth, and rejection stats.
    """
    if seed is not None:
        sage.set_random_seed(seed)
        random.seed(seed)
        np.random.seed(seed)
    
    rejections = 0
    for attempt in range(max_attempts):
        try:
            G_undirected = sage.graphs.RandomRegularGraph(n, b)
            girth = G_undirected.girth()
            if girth > target_girth:
                G_directed = sage.DiGraph(G_undirected)  # Symmetric directed edges
                return G_directed, girth, rejections
            rejections += 1
        except Exception as e:
            rejections += 1
            continue
    raise RuntimeError(f"Failed to generate graph with girth > {target_girth} after {max_attempts} attempts. Rejections: {rejections}")

def generate_ensemble(n, b, num_graphs, seed_base=2025, output_dir="graphs"):
    """
    Generate ensemble of b-regular graphs with girth > log_b(n).
    Saves metadata to CSV.
    """
    os.makedirs(output_dir, exist_ok=True)
    target_girth = int(np.ceil(np.log(n) / np.log(b))) + 1
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    metadata_file = os.path.join(output_dir, f"ensemble_n{n}_b{b}_g{target_girth}_{timestamp}.csv")
    
    graphs = []
    with open(metadata_file, 'w', newline='') as csvfile:
        fieldnames = ['graph_id', 'n', 'b', 'girth', 'target_girth', 'seed', 'rejections']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        
        for i in range(num_graphs):
            seed = seed_base + i
            print(f"Generating graph {i+1}/{num_graphs} (seed={seed})...")
            G, girth, rejections = generate_random_regular_graph_with_girth(n, b, target_girth, seed=seed)
            graphs.append(G)
            writer.writerow({
                'graph_id': i, 'n': n, 'b': b, 'girth': girth,
                'target_girth': target_girth, 'seed': seed, 'rejections': rejections
            })
    
    return graphs, metadata_file

# Module 2: Parallel Evolution Engine
class CLCEvolutionEngine:
    def __init__(self, alpha=1.0, temp_scale=1.0, seed=None):
        self.alpha = alpha
        self.temp_scale = temp_scale
        if seed is not None:
            sage.set_random_seed(seed)
            np.random.seed(seed)
    
    def compute_temperature(self, n):
        return self.temp_scale / np.log(n) if n > 1 else 1.0
    
    def propose_edges(self, G):
        """Propose edges forming 3-cycles."""
        proposals = set()
        for v in G.vertices():
            for w in G.neighbors_out(v):
                for u in G.neighbors_out(w):
                    if v != u and not G.has_edge(u, v):
                        proposals.add((u, v))
        return proposals
    
    def is_geometrically_pure(self, G, u, v):
        """Check if adding edge (u,v) forms exactly one 3-cycle and no longer cycles."""
        G_temp = G.copy()
        G_temp.add_edge(u, v)
        paths = list(G_temp.all_simple_paths(v, u, cutoff=4))
        two_paths = [p for p in paths if len(p) == 3]  # 3 vertices = path length 2
        longer_paths = [p for p in paths if len(p) > 3]
        return len(two_paths) == 1 and len(longer_paths) == 0
    
    def compute_free_energy(self, T):
        """Simplified free energy for 3-cycle formation: Δρ_C = 1, ΔS = 1."""
        return self.alpha * 1.0 - T * 1.0
    
    def accept_proposal(self, delta_f, T):
        if T <= 1e-9: return delta_f <= 0
        prob = np.exp(-delta_f / T)
        return np.random.random() < min(1.0, prob)
    
    def apply_rewrite_rule(self, G):
        """Apply one step of parallel rewrite rule R."""
        n = G.order()
        T = self.compute_temperature(n)
        proposals = self.propose_edges(G)
        valid_proposals = [(u, v) for (u, v) in proposals if self.is_geometrically_pure(G, u, v)]
        
        accepted_edges = []
        delta_f = self.compute_free_energy(T)
        for (u, v) in valid_proposals:
            if self.accept_proposal(delta_f, T):
                accepted_edges.append((u, v))
        
        G.add_edges(accepted_edges)
        return len(accepted_edges), T

    def evolve(self, G, max_steps=2000, log_interval=10):
        """Evolve graph for max_steps or until convergence."""
        trajectory = []
        for step in range(max_steps):
            num_accepted, T = self.apply_rewrite_rule(G)
            n3_cycles = int((G.to_undirected().adjacency_matrix()**3).trace() / 6)
            record = {
                'step': step, 'num_edges': G.size(), 'num_3cycles': n3_cycles,
                'temperature': T, 'accepted_edges': num_accepted
            }
            trajectory.append(record)
            if step % log_interval == 0:
                print(f"Step {step}: Accepted={num_accepted}, 3-cycles={n3_cycles}, T={T:.4f}")
            if num_accepted == 0:
                print(f"Converged at step {step}")
                break
        return trajectory

# Module 3: Observable Tracking
def compute_spectral_dimension(G_undirected, t_max=100):
    """Compute d_S via heat kernel method."""
    if G_undirected.order() == 0:
        return 0.0
    try:
        L = G_undirected.laplacian_matrix(sparse=True)
        eigenvalues = spla.eigsh(L, k=min(100, G_undirected.order()-1), which='SM', return_eigenvectors=False)
        t_range = np.arange(1, t_max + 1)
        heat_kernel_trace = np.sum(np.exp(-eigenvalues * t_range[:, None]), axis=1)
        
        log_t = np.log(t_range[9:])
        log_p = np.log(heat_kernel_trace[9:])
        mask = np.isfinite(log_p)
        if np.sum(mask) < 2:
            return 0.0
        coeffs = np.polyfit(log_t[mask], log_p[mask], 1)
        return -2 * coeffs[0]
    except Exception as e:
        print(f"Error computing d_S: {e}")
        return -1.0

def compute_ollivier_ricci_curvature(G_undirected, sample_edges=1000):
    """Compute Ollivier-Ricci curvature for sampled edges using Sinkhorn."""
    if G_undirected.size() == 0:
        return []
    edges = G_undirected.edges(labels=False)
    if len(edges) > sample_edges:
        edges = random.sample(edges, sample_edges)
    
    curvatures = []
    for v, u in edges:
        d = G_undirected.shortest_path_length(v, u)
        if d == 0:
            continue
        neighbors_v = list(G_undirected.neighbors(v))
        neighbors_u = list(G_undirected.neighbors(u))
        if len(neighbors_v) == 0 or len(neighbors_u) == 0:
            continue
        m_v = np.ones(len(neighbors_v)) / len(neighbors_v)
        m_u = np.ones(len(neighbors_u)) / len(neighbors_u)
        C = np.ones((len(neighbors_v), len(neighbors_u))) * d
        try:
            W_1 = ot.sinkhorn2(m_v, m_u, C, reg=0.1)
            kappa = 1 - W_1 / d
            curvatures.append(float(kappa))
        except:
            continue
    return curvatures if curvatures else [0.0]

def compute_spectral_embedding_distortion(G_undirected):
    """Compute distortion of Laplacian eigenmap into R^4."""
    try:
        L = G_undirected.laplacian_matrix(normalized=True, sparse=True)
        k = 5  # First 4 non-trivial eigenvectors + trivial
        eigenvalues, eigenvectors = spla.eigsh(L, k=k, which='SM')
        embedding = eigenvectors[:, 1:5]  # Skip trivial eigenvector
        distortion = 0.0
        edges = G_undirected.edges(labels=False)
        for u, v in random.sample(edges, min(1000, len(edges))):
            euclidean_dist = np.linalg.norm(embedding[u] - embedding[v])
            graph_dist = G_undirected.shortest_path_length(u, v)
            distortion += abs(euclidean_dist - graph_dist)
        return distortion / min(1000, len(edges)) if edges else 0.0
    except:
        return 0.0

def compute_laplacian_spectrum(G_undirected, k=5):
    """Compute first k eigenvalues of normalized Laplacian."""
    if G_undirected.order() <= k:
        return []
    try:
        L_norm = G_undirected.laplacian_matrix(normalized=True, sparse=True)
        eigenvalues = spla.eigsh(L_norm, k=k, which='SM', return_eigenvectors=False)
        return np.sort(eigenvalues)
    except:
        return []

def track_observables(G, step, traj_id, output_dir="observables"):
    """Compute and log observables."""
    G_undirected = G.to_undirected()
    d_s = compute_spectral_dimension(G_undirected)
    curvatures = compute_ollivier_ricci_curvature(G_undirected)
    laplacian_eigs = compute_laplacian_spectrum(G_undirected, k=5)
    distortion = compute_spectral_embedding_distortion(G_undirected)
    
    os.makedirs(output_dir, exist_ok=True)
    obs_file = os.path.join(output_dir, f"observables_traj{traj_id}.csv")
    record = {
        'traj_id': traj_id, 'step': step, 'd_s': d_s,
        'curv_mean': np.mean(curvatures) if curvatures else 0.0,
        'curv_std': np.std(curvatures) if curvatures else 0.0,
        'curv_skew': skew(curvatures) if curvatures else 0.0,
        'curv_kurt': kurtosis(curvatures) if curvatures else 0.0,
        'distortion': distortion,
        'spectral_gap': laplacian_eigs[1] - laplacian_eigs[0] if len(laplacian_eigs) >= 2 else 0.0
    }
    for i, eig in enumerate(laplacian_eigs):
        record[f'laplacian_eig_{i}'] = eig
    
    with open(obs_file, 'a', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=record.keys())
        if step == 0:
            writer.writeheader()
        writer.writerow(record)
    return record

# Module 4: Configuration and Execution
def run_ensemble_simulation(config):
    """Run full ensemble simulation and log results."""
    n = config['n']
    b = config['b']
    num_graphs = config['num_graphs']
    max_steps = config['max_steps']
    alpha = config['alpha']
    seed_base = config['seed_base']
    output_dir = config['output_dir']
    log_interval = config.get('log_interval', 10)
    
    os.makedirs(output_dir, exist_ok=True)
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    config_file = os.path.join(output_dir, f"config_{timestamp}.json")
    with open(config_file, 'w') as f:
        json.dump({
            **config,
            'software': {'python': platform.python_version(), 'numpy': np.__version__, 'scipy': scipy.__version__, 'ot': ot.__version__},
            'hardware': {'cpu': platform.processor(), 'cores': psutil.cpu_count(), 'ram': psutil.virtual_memory().total / 1e9}
        }, f, indent=2)
    
    graphs, meta_file = generate_ensemble(n, b, num_graphs, seed_base, output_dir)
    engine = CLCEvolutionEngine(alpha=alpha, seed=seed_base)
    
    for i, G in enumerate(graphs):
        print(f"\nEvolving graph {i+1}/{num_graphs}...")
        trajectory = engine.evolve(G, max_steps=max_steps, log_interval=log_interval)
        for record in trajectory[::log_interval]:
            obs = track_observables(G, record['step'], i, output_dir)
            print(f"Traj {i}, Step {record['step']}: d_S={obs['d_s']:.2f}, curv_mean={obs['curv_mean']:.2f}, distortion={obs['distortion']:.2f}, gap={obs['spectral_gap']:.2f}")

if __name__ == "__main__":
    config = {
        'n': 256, 'b': 3, 'num_graphs': 10, 'max_steps': 500,
        'alpha': 1.0, 'seed_base': 2025, 'log_interval': 10,
        'output_dir': f"clc_run_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    }
    run_ensemble_simulation(config)
